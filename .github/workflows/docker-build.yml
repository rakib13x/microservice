name: Build, Test & Deploy Microservices

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      force_build_all:
        description: 'Force build all services'
        required: false
        default: 'false'
        type: boolean

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_TOKEN }}
  AWS_REGION: us-east-1
  EC2_INSTANCE_TYPE: t3.xlarge

jobs:
  # Step 1: Detect what changed
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend-services: ${{ steps.changes.outputs.backend-services }}
      frontend-services: ${{ steps.changes.outputs.frontend-services }}
      any-backend-changed: ${{ steps.changes.outputs.any-backend-changed }}
      any-frontend-changed: ${{ steps.changes.outputs.any-frontend-changed }}
      any-changed: ${{ steps.changes.outputs.any-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed services
        uses: dorny/paths-filter@v2
        id: changes
        with:
          list-files: 'csv'
          filters: |
            api-gateway:
              - 'apps/api-gateway/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            auth-service:
              - 'apps/auth-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            product-service:
              - 'apps/product-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            order-service:
              - 'apps/order-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            seller-service:
              - 'apps/seller-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            admin-service:
              - 'apps/admin-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            chatting-service:
              - 'apps/chatting-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            kafka-service:
              - 'apps/kafka-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            logger-service:
              - 'apps/logger-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            recommendation-service:
              - 'apps/recommendation-service/**'
              - 'packages/**'
              - 'pnpm-lock.yaml'
            user-ui:
              - 'apps/user-ui/**'
              - 'packages/components/**'
              - 'pnpm-lock.yaml'
            seller-ui:
              - 'apps/seller-ui/**'
              - 'packages/components/**'
              - 'pnpm-lock.yaml'
            admin-ui:
              - 'apps/admin-ui/**'
              - 'packages/components/**'
              - 'pnpm-lock.yaml'

      - name: Set service groups
        id: groups
        run: |
          # Define services as space-separated strings
          BACKEND_SERVICES="auth-service product-service order-service seller-service admin-service chatting-service kafka-service logger-service recommendation-service"
          FRONTEND_SERVICES="user-ui seller-ui admin-ui"
          
          # Check if force build all is enabled
          if [[ "${{ github.event.inputs.force_build_all }}" == "true" ]]; then
            echo "üî® Force building all services"
            CHANGED_BACKEND='["auth-service","product-service","order-service","seller-service","admin-service","chatting-service","kafka-service","logger-service","recommendation-service","api-gateway"]'
            CHANGED_FRONTEND='["user-ui","seller-ui","admin-ui"]'
          else
            # Check which services changed
            CHANGED_BACKEND='[]'
            CHANGED_FRONTEND='[]'
            
            # Check each backend service individually
            if [[ "${{ steps.changes.outputs.auth-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"auth-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.product-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"product-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.order-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"order-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.seller-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"seller-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.admin-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"admin-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.chatting-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"chatting-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.kafka-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"kafka-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.logger-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"logger-service\"]")
            fi
            if [[ "${{ steps.changes.outputs.recommendation-service }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"recommendation-service\"]")
            fi
            
            # Check each frontend service individually
            if [[ "${{ steps.changes.outputs.user-ui }}" == "true" ]]; then
              CHANGED_FRONTEND=$(echo $CHANGED_FRONTEND | jq ". + [\"user-ui\"]")
            fi
            if [[ "${{ steps.changes.outputs.seller-ui }}" == "true" ]]; then
              CHANGED_FRONTEND=$(echo $CHANGED_FRONTEND | jq ". + [\"seller-ui\"]")
            fi
            if [[ "${{ steps.changes.outputs.admin-ui }}" == "true" ]]; then
              CHANGED_FRONTEND=$(echo $CHANGED_FRONTEND | jq ". + [\"admin-ui\"]")
            fi
            
            # Add api-gateway if any backend service changed or api-gateway itself changed
            if [[ "$CHANGED_BACKEND" != "[]" ]] || [[ "${{ steps.changes.outputs.api-gateway }}" == "true" ]]; then
              CHANGED_BACKEND=$(echo $CHANGED_BACKEND | jq ". + [\"api-gateway\"]")
            fi
            
            echo "backend-services=$CHANGED_BACKEND" >> $GITHUB_OUTPUT
            echo "frontend-services=$CHANGED_FRONTEND" >> $GITHUB_OUTPUT
            echo "any-backend-changed=$([ "$CHANGED_BACKEND" != "[]" ] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "any-frontend-changed=$([ "$CHANGED_FRONTEND" != "[]" ] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "any-changed=$([ "$CHANGED_BACKEND" != "[]" ] || [ "$CHANGED_FRONTEND" != "[]" ] && echo true || echo false)" >> $GITHUB_OUTPUT

  # Step 2: Build Backend Services (Critical - Must All Succeed)
  build-backend-services:
    needs: detect-changes
    if: needs.detect-changes.outputs.any-backend-changed == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.backend-services) }}
      fail-fast: true  # CRITICAL: Stop all if any fails
      max-parallel: 3
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: Check if image exists (Skip if unchanged)
        id: check-image
        run: |
          # Create a hash of the service directory
          SERVICE_HASH=$(find apps/${{ matrix.service }} packages -type f -name "*.ts" -o -name "*.js" -o -name "*.json" | xargs cat | sha256sum | cut -d' ' -f1)
          echo "service-hash=$SERVICE_HASH" >> $GITHUB_OUTPUT
          
          # Check if image with this hash exists
          if docker manifest inspect ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:$SERVICE_HASH >/dev/null 2>&1; then
            echo "skip-build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Image for ${{ matrix.service }} already exists with hash $SERVICE_HASH"
          else
            echo "skip-build=false" >> $GITHUB_OUTPUT
            echo "üî® Building new image for ${{ matrix.service }} with hash $SERVICE_HASH"
          fi

      - name: Build and test Docker image
        if: steps.check-image.outputs.skip-build == 'false'
        run: |
          cd apps/${{ matrix.service }}
          
          # Build the image
          docker build -t ${{ matrix.service }}:test .
          
          # Test the image (basic health check)
          docker run --rm -d --name ${{ matrix.service }}-test ${{ matrix.service }}:test
          sleep 10
          
          # Check if container is running
          if ! docker ps | grep -q "${{ matrix.service }}-test"; then
            echo "‚ùå ${{ matrix.service }} failed to start!"
            exit 1
          fi
          
          # Stop test container
          docker stop ${{ matrix.service }}-test
          
          echo "‚úÖ ${{ matrix.service }} built and tested successfully"

      - name: Push to Docker Hub
        if: steps.check-image.outputs.skip-build == 'false'
        run: |
          # Tag with hash and latest
          docker tag ${{ matrix.service }}:test ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:${{ steps.check-image.outputs.service-hash }}
          docker tag ${{ matrix.service }}:test ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest
          
          # Push both tags
          docker push ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:${{ steps.check-image.outputs.service-hash }}
          docker push ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest

  # Step 3: Test Backend Services Integration
  test-backend-integration:
    needs: [detect-changes, build-backend-services]
    if: needs.detect-changes.outputs.any-backend-changed == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create test environment with Kafka
        run: |
          # Create network
          docker network create eshop-test-network
          
          # Start Zookeeper
          docker run -d --name zookeeper-test --network eshop-test-network \
            -e ZOOKEEPER_CLIENT_PORT=2181 \
            -e ZOOKEEPER_TICK_TIME=2000 \
            confluentinc/cp-zookeeper:7.4.0
          
          sleep 10
          
          # Start Kafka
          docker run -d --name kafka-test --network eshop-test-network \
            -e KAFKA_BROKER_ID=1 \
            -e KAFKA_ZOOKEEPER_CONNECT=zookeeper-test:2181 \
            -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka-test:29092 \
            -e KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=PLAINTEXT:PLAINTEXT \
            -e KAFKA_INTER_BROKER_LISTENER_NAME=PLAINTEXT \
            -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \
            -e KAFKA_AUTO_CREATE_TOPICS_ENABLE=false \
            confluentinc/cp-kafka:7.4.0
          
          sleep 15
          
          # Create topics
          docker exec kafka-test kafka-topics --create --topic user-events --bootstrap-server localhost:29092 --replication-factor 1 --partitions 3
          docker exec kafka-test kafka-topics --create --topic logs --bootstrap-server localhost:29092 --replication-factor 1 --partitions 3
          docker exec kafka-test kafka-topics --create --topic chat.new_message --bootstrap-server localhost:29092 --replication-factor 1 --partitions 3

      - name: Start backend services in order
        run: |
          # Start core services first
          CORE_SERVICES=("auth-service" "product-service" "order-service" "seller-service" "admin-service")
          SUPPORT_SERVICES=("chatting-service" "kafka-service" "logger-service" "recommendation-service")
          
          # Start core services
          for service in "${CORE_SERVICES[@]}"; do
            if [[ "${{ needs.detect-changes.outputs.backend-services }}" == *"$service"* ]]; then
              echo "Starting $service..."
              docker run -d --name $service-test --network eshop-test-network \
                -e NODE_ENV=test \
                -e KAFKA_BROKERS=kafka-test:29092 \
                ${{ env.DOCKER_USERNAME }}/$service:latest
              
              # Wait and check health
              sleep 5
              if ! docker ps | grep -q "$service-test"; then
                echo "‚ùå $service failed to start!"
                docker logs $service-test
                exit 1
              fi
            fi
          done
          
          # Start support services
          for service in "${SUPPORT_SERVICES[@]}"; do
            if [[ "${{ needs.detect-changes.outputs.backend-services }}" == *"$service"* ]]; then
              echo "Starting $service..."
              docker run -d --name $service-test --network eshop-test-network \
                -e NODE_ENV=test \
                -e KAFKA_BROKERS=kafka-test:29092 \
                ${{ env.DOCKER_USERNAME }}/$service:latest
              sleep 3
            fi
          done
          
          # Finally start API Gateway
          if [[ "${{ needs.detect-changes.outputs.backend-services }}" == *"api-gateway"* ]]; then
            echo "Starting api-gateway..."
            docker run -d --name api-gateway-test --network eshop-test-network \
              -p 8080:8080 \
              -e NODE_ENV=test \
              -e KAFKA_BROKERS=kafka-test:29092 \
              ${{ env.DOCKER_USERNAME }}/api-gateway:latest
            
            sleep 10
            
            # Test API Gateway health
            if ! curl -f http://localhost:8080/health; then
              echo "‚ùå API Gateway health check failed!"
              docker logs api-gateway-test
              exit 1
            fi
            
            echo "‚úÖ All backend services are running and healthy!"
          fi

      - name: Cleanup test environment
        if: always()
        run: |
          docker stop $(docker ps -aq --filter network=eshop-test-network) 2>/dev/null || true
          docker rm $(docker ps -aq --filter network=eshop-test-network) 2>/dev/null || true
          docker network rm eshop-test-network 2>/dev/null || true

  # Step 4: Build Frontend Services (Independent)
  build-frontend-services:
    needs: detect-changes
    if: needs.detect-changes.outputs.any-frontend-changed == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.frontend-services) }}
      fail-fast: false  # Frontend can fail independently
      max-parallel: 3
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: Build and push frontend service
        run: |
          cd apps/${{ matrix.service }}
          docker build -t ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest .
          docker push ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest

  # Step 5: Deploy to EC2
  deploy-to-ec2:
    needs: [detect-changes, build-backend-services, test-backend-integration, build-frontend-services]
    if: github.ref == 'refs/heads/master' && needs.detect-changes.outputs.any-changed == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create or update EC2 instance
        run: |
          # Check if instance exists
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=eshop-production" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" --output text)
          
          if [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
            echo "Creating new EC2 instance..."
            
            # Create instance
            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ami-0c02fb55956c7d316 \
              --instance-type ${{ env.EC2_INSTANCE_TYPE }} \
              --key-name ${{ secrets.EC2_KEY_NAME }} \
              --security-group-ids ${{ secrets.EC2_SECURITY_GROUP }} \
              --subnet-id ${{ secrets.EC2_SUBNET_ID }} \
              --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=eshop-production}]' \
              --user-data file://scripts/ec2-user-data.sh \
              --query "Instances[0].InstanceId" --output text)
            
            echo "Waiting for instance to be ready..."
            aws ec2 wait instance-running --instance-ids $INSTANCE_ID
            sleep 60  # Additional time for user-data script
          fi
          
          # Get instance IP
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "INSTANCE_IP=$INSTANCE_IP" >> $GITHUB_ENV

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.INSTANCE_IP }}
          username: ec2-user
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          script: |
            # Update deployment script
            cd /home/ec2-user/eshop || git clone https://github.com/${{ github.repository }}.git eshop && cd eshop
            git pull origin master
            
            # Set environment variables
            export DOCKER_USERNAME=${{ env.DOCKER_USERNAME }}
            export CHANGED_BACKEND='${{ needs.detect-changes.outputs.backend-services }}'
            export CHANGED_FRONTEND='${{ needs.detect-changes.outputs.frontend-services }}'
            
            # Run deployment script
            chmod +x scripts/deploy-production.sh
            ./scripts/deploy-production.sh